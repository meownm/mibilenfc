/* Groovy way */
task clean(type: Delete) {
    delete rootProject.buildDir
}

tasks.register("verifyGradleDsl") {
    group = "verification"
    description = "Verifies Gradle files use Groovy DSL and avoid Kotlin DSL syntax."

    doLast {
        def kotlinPatterns = [
            ~/id\(\".*\"\)/,
            ~/implementation\(\".*\"\)/,
            ~/testImplementation\(\".*\"\)/,
            ~/api\(\".*\"\)/,
            ~/project\(\".*\"\)/,
            ~/platform\(\".*\"\)/,
            ~/include\(\".*\"\)/
        ]

        def requiredPatterns = [
            [file: "app/build.gradle", pattern: ~/id\s+'com\.android\.application'/],
            [file: "sdk/build.gradle", pattern: ~/id\s+'com\.android\.library'/],
            [file: "settings.gradle", pattern: ~/include\s+'(:app|:sdk)'/]
        ]

        def violations = []
        fileTree(rootDir) {
            include "**/*.gradle"
            exclude "**/build/**"
        }.each { gradleFile ->
            def text = gradleFile.getText("UTF-8")
            kotlinPatterns.each { pattern ->
                if (text =~ pattern) {
                    violations << "${gradleFile}: contains Kotlin DSL pattern ${pattern}"
                }
            }
        }

        requiredPatterns.each { requirement ->
            def targetFile = file(requirement.file)
            if (!targetFile.exists()) {
                violations << "${targetFile}: missing file for DSL verification"
            } else if (!(targetFile.getText("UTF-8") =~ requirement.pattern)) {
                violations << "${targetFile}: missing expected Groovy DSL pattern ${requirement.pattern}"
            }
        }

        if (!violations.isEmpty()) {
            throw new GradleException("Gradle DSL verification failed:\\n - " + violations.join("\\n - "))
        }
    }
}

tasks.register("verifyGradleSyncConfig") {
    group = "verification"
    description = "Verifies Gradle sync configuration and repository placement."

    doLast {
        def violations = []
        def settingsFile = file("settings.gradle")
        def settingsText = settingsFile.getText("UTF-8")

        if (!(settingsText =~ /id\s+"com\.android\.application"\s+version\s+"[^"]+"/)) {
            violations << "${settingsFile}: missing AGP version for com.android.application in pluginManagement.plugins"
        }
        if (!(settingsText =~ /id\s+"com\.android\.library"\s+version\s+"[^"]+"/)) {
            violations << "${settingsFile}: missing AGP version for com.android.library in pluginManagement.plugins"
        }

        fileTree(rootDir) {
            include "**/*.gradle"
            exclude "settings.gradle"
            exclude "**/build/**"
        }.each { gradleFile ->
            def text = gradleFile.getText("UTF-8")
            if (text =~ /buildscript\s*\{/) {
                violations << "${gradleFile}: buildscript blocks are not allowed outside settings.gradle"
            }
            if (text =~ /repositories\s*\{/) {
                violations << "${gradleFile}: repositories are only allowed in settings.gradle"
            }
        }

        if (!violations.isEmpty()) {
            throw new GradleException("Gradle sync configuration verification failed:\\n - " + violations.join("\\n - "))
        }
    }
}

tasks.register("verifyModuleNamespaces") {
    group = "verification"
    description = "Verifies app and SDK modules declare the expected distinct namespaces."

    doLast {
        def expectedNamespaces = [
            app: "com.example.emrtdreader",
            sdk: "com.example.emrtdreader.sdk"
        ]

        def violations = []
        expectedNamespaces.each { moduleName, expectedNamespace ->
            def moduleFile = file("${moduleName}/build.gradle")
            if (!moduleFile.exists()) {
                violations << "${moduleFile}: missing build.gradle to verify namespace"
            } else {
                def text = moduleFile.getText("UTF-8")
                def matcher = (text =~ /namespace\s+'([^']+)'/)
                if (!matcher.find()) {
                    violations << "${moduleFile}: missing namespace declaration"
                } else if (matcher.group(1) != expectedNamespace) {
                    violations << "${moduleFile}: namespace ${matcher.group(1)} does not match expected ${expectedNamespace}"
                }
            }
        }

        if (!violations.isEmpty()) {
            throw new GradleException("Module namespace verification failed:\\n - " + violations.join("\\n - "))
        }
    }
}

tasks.register("verifyDistinctNamespaces") {
    group = "verification"
    description = "Fails if the app and SDK modules share the same namespace."

    doLast {
        def appFile = file("app/build.gradle")
        def sdkFile = file("sdk/build.gradle")
        def violations = []

        if (!appFile.exists() || !sdkFile.exists()) {
            violations << "Missing build.gradle for app or sdk modules."
        } else {
            def appNamespaceMatcher = (appFile.getText("UTF-8") =~ /namespace\s+'([^']+)'/)
            def sdkNamespaceMatcher = (sdkFile.getText("UTF-8") =~ /namespace\s+'([^']+)'/)

            if (!appNamespaceMatcher.find()) {
                violations << "${appFile}: missing namespace declaration"
            }
            if (!sdkNamespaceMatcher.find()) {
                violations << "${sdkFile}: missing namespace declaration"
            }

            if (violations.isEmpty() && appNamespaceMatcher.group(1) == sdkNamespaceMatcher.group(1)) {
                violations << "App and SDK namespaces are identical (${appNamespaceMatcher.group(1)})."
            }
        }

        if (!violations.isEmpty()) {
            throw new GradleException("Distinct namespace verification failed:\\n - " + violations.join("\\n - "))
        }
    }
}

tasks.register("verifySdkPackageDeclarations") {
    group = "verification"
    description = "Verifies SDK source and test packages are under com.example.emrtdreader.sdk."

    doLast {
        def violations = []
        [file("sdk/src/main/java"), file("sdk/src/test/java")].each { rootDir ->
            if (!rootDir.exists()) {
                return
            }
            fileTree(rootDir) {
                include "**/*.java"
            }.each { sourceFile ->
                def text = sourceFile.getText("UTF-8")
                def matcher = (text =~ /^package\s+([\\w\\.]+);/)
                if (!matcher.find()) {
                    violations << "${sourceFile}: missing package declaration"
                } else if (!matcher.group(1).startsWith("com.example.emrtdreader.sdk")) {
                    violations << "${sourceFile}: package ${matcher.group(1)} is outside expected SDK namespace"
                }
            }
        }

        if (!violations.isEmpty()) {
            throw new GradleException("SDK package declaration verification failed:\\n - " + violations.join("\\n - "))
        }
    }
}

tasks.register("verifyAppSdkIntegration") {
    group = "verification"
    description = "Builds the app module with the SDK dependency to validate integration."

    dependsOn(":app:assembleDebug")

    doLast {
        def appBuildFile = file("app/build.gradle")
        if (appBuildFile.exists()) {
            def text = appBuildFile.getText("UTF-8")
            if (!(text =~ /implementation\\s+project\\(':sdk'\\)/)) {
                throw new GradleException("app/build.gradle is missing implementation project(':sdk') dependency.")
            }
        }
    }
}
